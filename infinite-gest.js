// Generated by CoffeeScript 1.9.3
(function() {
  var Gest, ij, ijs, j, len1;

  Gest = function(el) {
    var Fabric, backToDrawing, canvas, currentZoom, fabric, gestureZoom, lastPan, pointerTimeout, recogniser, rect, rect2, resize, scale, startPointer, text, text2, text3;
    canvas = document.createElement('canvas');
    el.appendChild(canvas);
    Fabric = window.fabric;
    fabric = new Fabric.Canvas(canvas);
    resize = function() {
      canvas.width = el.offsetWidth;
      canvas.height = el.offsetHeight;
      fabric.setWidth(canvas.width);
      return fabric.setHeight(canvas.height);
    };
    resize();
    window.addEventListener('resize', resize);
    rect = new Fabric.Rect({
      left: 100,
      top: 200,
      fill: 'red',
      width: 100,
      height: 100
    });
    rect2 = new Fabric.Rect({
      left: 300,
      top: 200,
      fill: 'blue',
      width: 100,
      height: 100
    });
    text = new Fabric.Text("Tap/click and drag to draw", {
      left: 100,
      top: 0
    });
    text2 = new Fabric.Text("Long press to select and move", {
      left: 100,
      top: 50
    });
    text3 = new Fabric.Text("Two fingers to pan and zoom", {
      left: 100,
      top: 100
    });
    fabric.add(rect, rect2, text, text2, text3);
    fabric.isDrawingMode = true;
    fabric.freeDrawingCursor = fabric.defaultCursor;
    fabric.on('touch:longpress', function(ev) {
      var ref;
      console.log("LONGPRESS!");
      if ((ref = ev.e.type) === 'mouseup' || ref === 'touchend') {
        return;
      }
      ev.e.fromLongPress = true;
      fabric._isCurrentlyDrawing = false;
      fabric.isDrawingMode = false;
      return fabric._onMouseDown(ev.e);
    });
    backToDrawing = false;
    fabric.on('mouse:down', function(ev) {
      var pointer, shouldClear, target;
      if (fabric.isDrawingMode || ev.e.fromLongPress) {
        return;
      }
      console.log("mouse DOWN");
      backToDrawing = true;
      target = fabric.findTarget(ev.e);
      shouldClear = fabric._shouldClearSelection(ev.e, target);
      console.log("mousedown!", ev, "target", target, "shouldClear", shouldClear);
      if (shouldClear) {
        pointer = fabric.getPointer(ev.e, true);
        fabric._clearSelection(ev.e, target, pointer);
        return fabric._groupSelector = null;
      }
    });
    fabric.on('mouse:up', function(ev) {
      if (!backToDrawing) {
        return;
      }
      backToDrawing = false;
      return fabric.isDrawingMode = true;
    });
    scale = function(n) {
      if (n < 0) {
        return 1 / (-(n - 1));
      } else {
        return n + 1;
      }
    };
    currentZoom = 1;
    startPointer = null;
    pointerTimeout = null;
    fabric.wrapperEl.addEventListener('mousewheel', function(ev) {
      ev.preventDefault();
      if (ev.ctrlKey) {
        currentZoom -= ev.deltaY * 0.2;
        startPointer = fabric.getPointer(ev, true);
        return fabric.zoomToPoint(startPointer, scale(currentZoom));
      } else {
        return fabric.relativePan({
          x: -ev.deltaX,
          y: -ev.deltaY
        });
      }
    });
    fabric.__oldOnTransformGesture = fabric.__onTransformGesture;
    fabric.__onTransformGesture = function(e, self) {
      if (self.fingers === 2) {
        fabric._isCurrentlyDrawing = false;
        fabric.isDrawingMode = false;
      }
      return this.__oldOnTransformGesture(e, self);
    };
    gestureZoom = 1;
    lastPan = null;
    fabric.on('touch:gesture', function(ev) {
      console.log("touchgesture");
      gestureZoom = ev.self.scale;
      fabric.zoomToPoint(ev.self, currentZoom * gestureZoom);
      if (lastPan) {
        fabric.relativePan({
          x: ev.self.x - lastPan.x,
          y: ev.self.y - lastPan.y
        });
      }
      return lastPan = {
        x: ev.self.x,
        y: ev.self.y
      };
    });
    fabric.on('mouse:up', function(ev) {
      if (lastPan) {
        console.log("lastpan");
        fabric.isDrawingMode = true;
      }
      currentZoom *= gestureZoom;
      gestureZoom = 1;
      return lastPan = null;
    });
    recogniser = new PDollarRecognizer();
    Fabric.PencilBrush.prototype.onMouseUp = function() {
      var bottom, j, left, len1, norm, point, points, ref, ref1, result, right, top, x, y;
      points = (function() {
        var j, len1, ref, ref1, results;
        ref = this._points;
        results = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          ref1 = ref[j], x = ref1.x, y = ref1.y;
          results.push({
            x: x,
            y: y,
            id: 0
          });
        }
        return results;
      }).call(this);
      result = recogniser.Recognize(points);
      console.log("recogniser says", result);
      left = this._points[0].x;
      right = this._points[0].x;
      top = this._points[0].y;
      bottom = this._points[0].y;
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        ref1 = ref[j], x = ref1.x, y = ref1.y;
        if (x < left) {
          left = x;
        }
        if (x > right) {
          right = x;
        }
        if (y < top) {
          top = y;
        }
        if (y > bottom) {
          bottom = y;
        }
      }
      norm = function(arg) {
        var id, x, y;
        x = arg.x, y = arg.y, id = arg.id;
        return {
          x: (x + 0.5) * (right - left) + left,
          y: (y + 0.5) * (bottom - top) + top,
          id: id
        };
      };
      if (result.score > 0.1) {
        this._points = (function() {
          var k, len2, ref2, results;
          ref2 = result.result.Points;
          results = [];
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            point = ref2[k];
            results.push(norm(point));
          }
          return results;
        })();
      }
      return this._finalizeAndAddPath();
    };
    return Fabric.PencilBrush.prototype.convertPointsToSVGPath = function(points) {
      var i, len, midPoint, p1, p2, path;
      path = [];
      p1 = new Fabric.Point(points[0].x, points[0].y);
      p1.id = points[0].id;
      p2 = new Fabric.Point(points[1].x, points[1].y);
      p2.id = points[1].id;
      path.push('M ', points[0].x, ' ', points[0].y, ' ');
      i = 1;
      len = points.length;
      while (i < len) {
        if (p2.id === p1.id) {
          midPoint = p1.midPointFrom(p2);
          path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
        } else {
          path.push('L ', p1.x, ' ', p1.y, ' ');
          path.push('M ', p2.x, ' ', p2.y, ' ');
        }
        p1 = new Fabric.Point(points[i].x, points[i].y);
        p1.id = points[i].id;
        if (i + 1 < points.length) {
          p2 = new Fabric.Point(points[i + 1].x, points[i + 1].y);
          p2.id = points[i + 1].id;
        }
        i++;
      }
      path.push('L ', p1.x, ' ', p1.y, ' ');
      return path;
    };
  };

  window.Gest = Gest;

  ijs = document.getElementsByTagName('infinite-jest');

  for (j = 0, len1 = ijs.length; j < len1; j++) {
    ij = ijs[j];
    Gest(ij);
  }

}).call(this);
